알고리즘 문제해결 전략 226p

## 문제
```
6
1  2
3  7  4
9  4  1  7
2  7  5  9  4
```
위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요.

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 삼각형의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에는 각 1개~n개의 숫자로 삼각형 각 가로줄에 있는 숫자가 왼쪽부터 주어집니다. 각 숫자는 1 이상 100000 이하의 자연수입니다.

### 출력

각 테스트 케이스마다 한 줄에 최대 경로의 숫자 합을 출력합니다.

### 예제 입력
```
2
5
6
1  2
3  7  4
9  4  1  7
2  7  5  9  4
5
1 
2 4
8 16 8
32 64 32 64
128 256 128 256 128
```
### 예제 출력
```
28
341
```

### 문제 접근

메모이제이션을 이용하여 현재 높이 기준 다음 패스에 대한 최대값을 기록해가면서 탐색한다.
큰쪽의 결과가 최종 결과가 된다.
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

int h;
int T[100][100];
int cache[100][100];

int path(int y, int x) {
  if (y == h-1) {
    return T[y][x];
  }
  int &ret = cache[y][x];
  if(ret != -1) {
    return ret;
  }
  return ret = max(path(y+1, x), path(y+1, x+1)) + T[y][x];
}

int main() {
  int TC;
  scanf("%d", &TC);
  while(TC--) {
    scanf("%d", &h);
    memset(cache, -1, sizeof(cache));
    for(int i=0; i<h; ++i) {
      for(int j=0; j<=i; ++j) {
        scanf("%d", &T[i][j]);
      }
    }
    printf("%d\n", path(0,0));
  }
}
```