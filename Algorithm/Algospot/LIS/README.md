알고리즘 문제해결 전략 230p

## 문제

어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열 (subsequence) 를 얻을 수 있다. 예를 들어 10 7 4 9 의 부분 수열에는 7 4 9, 10 4, 10 9 등이 있다. 단, 10 4 7 은 원래 수열의 순서와 다르므로 10 7 4 9 의 부분 수열이 아니다.

어떤 부분 수열이 순증가할 때 이 부분 수열을 증가 부분 수열 (increasing subsequence) 라고 한다. 주어진 수열의 증가 부분 수열 중 가장 긴 것의 길이를 계산하는 프로그램을 작성하라.

어떤 수열의 각 수가 이전의 수보다 클 때, 이 수열을 순증가 한다고 한다.

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열에 포함된 원소의 수 N (<= 500) 이 주어진다. 그 다음 줄에 수열이 N개의 정수가 주어진다. 각 정수는 1 이상 100,000 이하의 자연수이다.

### 출력

각 테스트케이스마다 한 줄씩, 주어진 수열의 가장 긴 증가 부분 수열의 길이를 출력한다.

### 예제 입력
```
3
4
1 2 3 4
8
5 4 3 2 1 6 7 8 
8
5 6 7 8 1 2 3 4
```
### 예제 출력
```
4
4
4
```

## 문제 접근

완전 탐색으로 문제를 1차 해결한다.

선택한 아이템 이후 순번중에서 선택한 아이템보다 큰 숫자만 포함하는 부분 집합을 계속해서 만들어 나간다.

이때 원소가 하나인 집합도 부분집합이기 때문에 최소 크기는 1이 된다.


```cpp
int lis(vector<int> &S) {
  if (!S.size()) return 0;
  int ret = 0;
  for(int i=0; i<S.size(); ++i) {
    vector<int> sub;
    for(int j=i+1; j<S.size(); ++j) {
      if(S[i] < S[j]) {
        sub.push_back(S[j]);
      }
    }
    ret = max(ret,  1+lis(sub));
  }
  return ret;
}
```

각 단계마다 필요한것은 i번째 항목으로 시작하는 순증가 부분집합의 가장 긴 길이이다. 이를 저장하는 캐시를 이용하면 다음과 같이 메모이제이션 방법으로 구할 수 있다.

```cpp
int lis(int start) {
  int &ret = &cache[start+1];
  if (ret != -1) return ret;

  ret = 1;
  for (int next = start+1; next < n; ++next) {
    if(start == -1 || S[start] < S[next]) {
      ret = max(ret, 1 + lis(next));
    }
  }
  return ret;
}
```
