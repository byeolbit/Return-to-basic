# PICNIC
## 문제

안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다. 원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다. 그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 항상 서로 친구인 학생들끼리만 짝을 지어 줘야 합니다.

각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝지어줄 수 있는 방법의 수를 계산하는 프로그램을 작성하세요. 짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다. 예를 들어 다음 두 가지 방법은 서로 다른 방법입니다.

(태연,제시카) (써니,티파니) (효연,유리)
(태연,제시카) (써니,유리) (효연,티파니)
입력

입력의 첫 줄에는 테스트 케이스의 수 C (C <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 학생의 수 n (2 <= n <= 10) 과 친구 쌍의 수 m (0 <= m <= n*(n-1)/2) 이 주어집니다. 그 다음 줄에 m 개의 정수 쌍으로 서로 친구인 두 학생의 번호가 주어집니다. 번호는 모두 0 부터 n-1 사이의 정수이고, 같은 쌍은 입력에 두 번 주어지지 않습니다. 학생들의 수는 짝수입니다.

### 출력

각 테스트 케이스마다 한 줄에 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력합니다.

## 문제 접근

이 문제는 조합문제다

조합 nCr은 순서에 상관없이 n개중 r개를 선택하는 모든 조합의 경우의 수를 말한다.

이 문제는 서로 다른 학생 n명중 2명씩 n/2쌍을 짝짓는 방법에 대한 문제이다.

다만 추가된 조건이라면 미리 짝지을 수 있는 경우가 정해져 있어, 이를 만족하는 경우에만 조합이 되어야 한다.

처음 접근한 풀이 방법은 다음과 같다.

1. 2차원배열 pair를 만들어 지을 수 있는 모든 짝을 저장한다.
2. 사용한 번호의 엔트리를 만들어 앞에서부터 순차적으로 재귀로 찾아 내려간다.

그러나 쉽게 풀리지 않았다. 로직은 맞다고 생각했는데, 엔트리를 가지고 내려가면서 이미 선택했던 조합들을 표기하는데서 생각이 꼬였다.
특히
1. 엔트리를 어디까지 가지고 내려갈 것인가
2. 이미 사용한 조합인지아닌지 어떻게 표기할 것인가

조합을 구하긴 했는데 중복되게 구해서 2, 24, 192같은 어마어마하게 큰 값이 나오거나, 아니면 이미 지나간 것들을 구별하지 못해 그냥 n/2번 반복해서 1을 더하기만 하는 상황에서 빠져나오지 못했다.

풀이를 읽고나서 사실 2는 쓸데 없는 고민이었다는 것을 알게 되었다.

모두 하나씩 짝이 생기므로 0번째 항목을 쓰지 않는 조합은 있을 수 없다.
순차적으로 0과 가능한 조합을 순서대로 체크해가며 재귀호출하면 해결되는 일이었다.

```c++
#include <cstdio>
#include <string.h>
using namespace std;

int P[10][10] = {0,};
int n, p;

int matching(int m[10]) {
    int a = -1;
    int r = 0;
    for (int i=0; i<n; i++) {
        if(!m[i]) {
            a = i;
            break;
        }
    }
    if (a == -1) return 1;
    for (int i=a+1; i<n; i++) {
        if(!m[i] && P[a][i]) {
            m[a] = m[i] = 1;
            r += matching(m);
            m[a] = m[i] = 0;
        }
    }
    return r;
}

int main() {
    int T;
    scanf("%d", &T);
    while(T--) {
        for(int i=0; i<10; i++) {
            memset(P[i], 0, sizeof(int)*10);
        }
        scanf("%d %d", &n, &p);
        int temp_a=0, temp_b=0;
        for (int i=0; i<p; i++) {
            scanf("%d %d", &temp_a, &temp_b);
            P[temp_a][temp_b] = 1;
            P[temp_b][temp_a] = 1;
        }
        int M[10] = {0,};
        printf("%d\n", matching(M));
    }
}

```

## 문제를 풀기위해 참고한 자료들

접근 방법은 맞는것 같은데, 문제가 도저히 풀리지 않아 조합 개념부터 다시 뒤져봤었다.

### 조합 

서로 다른 n개에서 순서를 생각하지 않고 r개(0<=r<=n)를 택하는 것을 조합이라고 한다.
n 원소를 가지는 집합에서 r개의 부분집합을 고르는 조합의 경우의 수를 이항 계수라 한다.

조합의 성질
```
nCr = nCn-r
```
```
nCr = n-1Cr-1 + n-1Cr
```

서로 다른 n개의 물건을 p개, q개, r개의 3개의 그룹으로 나누는 방법은 다음과 같다.
```
nCp * n-pCq * rCr
```
### 중복 조합

조합이지만, 중복을 허락하는 경우
`nHr` 로 표기한다.
```
nHr = n+r-1Cr
```

참고
http://hochulshin.com/permutation-composition-summary
http://mentalplex.blogspot.kr/2012/03/blog-post_22.html
